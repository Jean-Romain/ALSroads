#' Snap road endings
#'
#' Snap road endings together, with and without prior knowledge on road connections, to post-process
#' and correct inaccuracies generated by \link{measure_roads} and ensure getting topologically valid
#' network. If argument 'ref' is missing the method is very basic. The methods using a reference map
#' is more advanced.
#'
#' @param roads  multiples lines (\code{sf} format). Corrected but unconnected roads.
#' @param ref  multiples lines (\code{sf} format). Original non-corrected but connected roads. Can be
#' missing.
#' @param tolerance numeric (distance unit). Tolerance value used to snap the road endings.
#' @param field  character. Unique identifier field in both road datasets. Relevant only is 'ref' is
#' not missing.
#'
#' @return The same object as \code{roads} but with corrected ending such that roads are connected.
#' @examples
#' f <- system.file("extdata", "road_network.gpkg", package="MFFProads")
#'
#' ref <- sf::st_read(f, layer = "original")  # input of measure_roads
#' cor <- sf::st_read(f, layer = "invalid_topology") # output of measure_roads
#' res <- st_snap_lines(cor, ref, field = "OBJECTID")
#'
#' plot(sf::st_geometry(ref), xlim = c(260800, 261000), ylim = c(5250400, 5250600), col = "red")
#' plot(sf::st_geometry(cor), col = "blue", add = TRUE)
#' plot(sf::st_geometry(res), col = "darkgreen", add = TRUE)
#' @export
st_snap_lines = function(roads, ref, tolerance = 30, field = NULL)
{
  if (missing(ref))
    return(simple_snap(roads, tolerance))

  if (!missing(ref) & is.null(field))
    stop("Argument 'field' cannot be NULL if a reference topology is provided", call. = FALSE)

  return(advanced_snap(roads, ref, field, tolerance))
}

simple_snap <- function(roads, tolerance)
{
  end   <- lwgeom::st_endpoint(roads)
  start <- lwgeom::st_startpoint(roads)
  ends  <- c(start, end)

  u <- sf::st_is_within_distance(ends, ends, tolerance)
  u <- lapply(u, sort)
  u <- Filter(function(x) { length(x) > 1}, u)
  u <- unique(u)
  u <- lapply(u, function(x) { ends[x] })
  u <- lapply(u, function(x) { sf::st_sfc(sf::st_point(colMeans(sf::st_coordinates(x)))) })
  u <- do.call(c, u)

  if (is.null(u)) {
    dist_unit <- sf::st_crs(u)$units
    warning(glue::glue("No roads could be snapped with the tolerance used ({tolerance} {dist_unit}). Original roads returned."), call. = FALSE)
    return(roads)
  }

  sf::st_crs(u) <- sf::st_crs(roads)

  v <- sf::st_is_within_distance(u, start, tolerance)
  for (i in seq_along(v))
  {
    ids <- v[[i]]
    for(j in ids)
    {
      sf::st_geometry(roads[j,])[[1]][1, 1] <- u[i][[1]][[1]]
      sf::st_geometry(roads[j,])[[1]][1, 2] <- u[i][[1]][[2]]
    }
  }

  w <- sf::st_is_within_distance(u, end, tolerance)
  for (i in seq_along(w))
  {
    ids <- w[[i]]
    for(j in ids)
    {
      n <- nrow(sf::st_geometry(roads[j,])[[1]])
      sf::st_geometry(roads[j,])[[1]][n, 1] <- u[i][[1]][[1]]
      sf::st_geometry(roads[j,])[[1]][n, 2] <- u[i][[1]][[2]]
    }
  }

  end   <- lwgeom::st_endpoint(roads)
  start <- lwgeom::st_startpoint(roads)
  idx_idem <- which(end == start)

  if (length(idx_idem)) {
    idx_roads <- glue::glue_collapse(idx_idem, ", ")
    warning(glue::glue("The following roads had both of their ends being snapped together: {idx_roads}"), call. = FALSE)
  }

  return(roads)
}

advanced_snap <- function(roads, roads_ori, field, tolerance)
{
  X <- Y <- id <- SCORE <- CLASS <- NULL

  IDs1 <- sort(unique(roads[[field]]))
  IDs2 <- sort(unique(roads_ori[[field]]))
  if (length(IDs1) != length(roads[[field]])) stop("Values in unique identifier field are not unique for 'roads'.", call. = FALSE)
  if (length(IDs2) != length(roads_ori[[field]])) stop("Values in unique identifier field are not unique for 'roads_ori'.", call. = FALSE)
  if (!all(IDs1 == IDs2)) stop("Values in unique identifier field are not the same in both road datasets.", call. = FALSE)

  dist_unit <- sf::st_crs(roads)$units

  # Arrange both road datasets to make sure
  # that line indices will match between them
  roads <- dplyr::arrange(roads, field)
  roads_ori <- dplyr::arrange(roads_ori, field)

  prepare_data <- function(roads, end = FALSE)
  {
    if (end) {
      get_end <- lwgeom::st_endpoint
    } else {
      get_end <- lwgeom::st_startpoint
    }

    out <- get_end(roads) |>
      sf::st_coordinates() |>
      dplyr::as_tibble() |>
      dplyr::mutate(pos = 1:nrow(roads)) |>
      dplyr::mutate(end = end) |>
      dplyr::mutate(id = paste0(roads[[field]], "_", end))

    return(out)
  }

  # Extraction of roads end points coordinates along with heading and
  # association with a unique identifier

  # Corrected roads
  tb_endpoint <- prepare_data(roads, TRUE)
  tb_startpoint <- prepare_data(roads, FALSE)

  tb_ends_roads <- rbind(tb_endpoint, tb_startpoint) |>
    dplyr::mutate(SCORE = rep(roads[["SCORE"]], 2)) |>
    dplyr::mutate(CLASS = rep(roads[["CLASS"]], 2))

  # Non-corrected roads
  tb_endpoint   <- prepare_data(roads_ori, TRUE)
  tb_startpoint <- prepare_data(roads_ori, FALSE)

  ls_heading <- lapply(sf::st_geometry(roads_ori), st_ends_heading)
  heading_tail_head <- c(sapply(ls_heading, utils::tail, 1),
                         sapply(ls_heading, utils::head, 1))

  tb_ends_ori <- rbind(tb_endpoint, tb_startpoint) |>
    dplyr::mutate(norm_heading = ifelse(heading_tail_head < 0, heading_tail_head + 180, heading_tail_head))


  # List of distinct connected nodes in the
  # non-corrected roads dataset
  tb_nodes_grouped <- tb_ends_ori |>
    dplyr::group_by(X, Y)

  if (nrow(tb_nodes_grouped) == 0) stop("No road junction has been found in original road dataset.", call. = FALSE)

  ls_tb_nodes <- tb_nodes_grouped |>
    dplyr::group_split() |>
    lapply(function(x) if (nrow(x) > 1) x)
  ls_tb_nodes <- ls_tb_nodes[!sapply(ls_tb_nodes, is.null)]


  # Try snapping together each segment at each node found.
  # This loop can't be vectorised because of the geometry
  # change occuring at both ends of a same road segment
  for (tb_node in ls_tb_nodes)
  {
    IDs <- tb_node[["id"]]
    tb_node_ori <- dplyr::filter(tb_ends_ori, id %in% IDs)
    tb_node_cor <- dplyr::filter(tb_ends_roads, id %in% IDs)


    # Will only try snapping if at least one of the segments
    # in the group has been corrected as they will already
    # be connected if none has been corrected
    been_corrected <- any(tb_node_cor[["CLASS"]] %in% c(1,2))
    if (!been_corrected) next


    # Find the two segments that are the most
    # likely to be the extension of each other
    # Those two are marked out as the "bridge"
    bridge_ids <- tb_node_ori |>
      dplyr::left_join(dplyr::select(tb_node_cor, id, SCORE, CLASS), by = "id") |>
      find_best_connexion()

    tb_node_bridge <- dplyr::filter(tb_node_cor, id %in% bridge_ids)

    # Make sure the gap between the two segments that
    # will make the bridge isn't exceeding tolerance
    gap <- sqrt(diff(tb_node_bridge[["X"]])^2 + diff(tb_node_bridge[["Y"]])^2)
    if (gap/2 > tolerance)
    {
      pos <- tb_node[["pos"]]
      IDs_field <- roads[pos,][[field]]
      IDs_glued <- glue::glue_collapse(IDs_field, ", ")

      warning(glue::glue("Impossible to connect together roads with '{field}' {IDs_glued}; distance from expected junction exceed tolerance ({round(gap/2,1)} > {tolerance} {dist_unit})."), call.=FALSE)
      next
    }


    # If there is only two segments, there is no need
    # to try finding a better junction point with a
    # non-existent third or fourth segment...
    if (length(IDs) == 2)
    {
      # Update geometry of the two corrected segments composing the bridge
      for (j in 1:2)
      {
        pos <- tb_node_bridge[j,][["pos"]]
        n <- if (tb_node_bridge[j,][["end"]])
        {
          nrow(sf::st_coordinates(roads[pos,]))
        } else {
          1
        }

        sf::st_geometry(roads[pos,])[[1]][n, 1] <- mean(tb_node_bridge[["X"]])
        sf::st_geometry(roads[pos,])[[1]][n, 2] <- mean(tb_node_bridge[["Y"]])
      }
      next
    }


    # Merge the two segments forming the bridge.
    # This will allow for an easier split when the
    # exact position of the junction will be found.
    bridge <- make_bridge(roads, tb_node_bridge)


    # Find intersection points between the remaining
    # segments and the bridge. The intersection point
    # is given as the distance on the path between
    # the begining of the bridge and intersection point
    remain_ids <- IDs[!(IDs %in% bridge_ids)]
    tb_node_remain <- dplyr::filter(tb_node_cor, id %in% remain_ids)

    pos <- tb_node_remain[["pos"]]
    end <- tb_node_remain[["end"]]
    head_tail = sapply(as.numeric(end) + 1, function(x) c("HEAD", "TAIL")[x])

    lines_extended <- roads[pos,] |>
        sf::st_geometry() |>
        mapply(999999, head_tail, FUN = st_extend_line, SIMPLIFY = FALSE) |>
        sf::st_sfc(crs = sf::st_crs(roads))

    dist_bridge <- sapply(lines_extended,
                          distance_line_intersection,
                          bridge[["bridge"]],
                          bridge[["junction"]])


    # Check if all intersections occur within the tolerance
    # value of the mean junction
    no_intersection <- sapply(dist_bridge, is.na)
    dist_junction_mean <- mean(dist_bridge, na.rm = TRUE)
    dist_junction_diff <- abs(dist_bridge - dist_junction_mean)
    dist_junction_diff[no_intersection] <- Inf
    dist_max <- max(dist_junction_diff)

    if (dist_max > tolerance)
    {
      pos <- tb_node[["pos"]]
      IDs_field <- roads[pos,][[field]]
      IDs_glued <- glue::glue_collapse(IDs_field, ", ")

      warning(glue::glue("Impossible to connect together roads with '{field}' {IDs_glued}; distance from expected junction exceed tolerance ({round(dist_max,1)} > {tolerance} {dist_unit})."), call.=FALSE)
      next
    }

    # Find coordinates of the point where
    # all remaining segments intersect the bridge
    # based on the mean intersection distance
    # along the bridge from its begining
    mean_junction <- st_point_on_line(dist_junction_mean, bridge[["bridge"]])

    # Split bridge geometry to recreate the original
    # two segments composing it and get coordinates
    # of the final junction point
    bridge_geometries <- st_split_at_point(mean_junction, bridge[["bridge"]])
    coords_junction <- sf::st_coordinates(bridge_geometries[2])[1,-3]

    # Reorder vertices in order to match the original
    # two segments forming the bridge
    for (k in which(bridge[["reversed"]]))
    {
      bridge_geometries[k][[1]] <- sf::st_coordinates(bridge_geometries[k])[,-3] |>
        apply(2, rev) |>
        sf::st_linestring()
    }

    # Update geometry of the two corrected segments composing the bridge
    pos <- tb_node_bridge[["pos"]]
    sf::st_geometry(roads[pos,]) <- bridge_geometries


    # Update coordinates of remaining segments
    # by splitting in order to avoid potential
    # overlapping segment if it was already crossing
    # the bridge before elongation
    idx_valid_intersection <- which(!no_intersection)
    for (j in idx_valid_intersection)
    {
      pos <- tb_node_remain[j,][["pos"]]
      end <- tb_node_remain[j,][["end"]]
      head_tail = c("HEAD", "TAIL")[as.numeric(end) + 1]

      road_extended <- roads[pos,] |>
        sf::st_geometry() |>
        st_extend_line(999999, head_tail)

      road_split <- road_extended |>
        lwgeom::st_split(bridge[["bridge"]]) |>
        sf::st_collection_extract("LINESTRING")


      # Find vertices coordinates corresponding
      # to the bulk of the original segment which
      # aren't those between the extended vertex
      # and the junction vertex with the bridge
      coords_split <- sf::st_coordinates(road_split)
      coords_extended <- sf::st_coordinates(road_extended)
      n <- ifelse(end, nrow(coords_extended), 1)
      x_match_extended <- coords_split[,"X"] == coords_extended[n, "X"]
      y_match_extended <- coords_split[,"Y"] == coords_extended[n, "Y"]
      idx_match_extended <- which(x_match_extended & y_match_extended)

      # Some tolerance must be added due to slight imprecision
      # in the coordinates returned by st_point_on_line()
      coords_intersect <- dist_bridge[j] |>
        st_point_on_line(bridge[["bridge"]]) |>
        sf::st_coordinates()

      x_match_junc <- (coords_split[,"X"] > (coords_intersect[1,"X"] - 0.01)) &
                      (coords_split[,"X"] < (coords_intersect[1,"X"] + 0.01))
      y_match_junc <- (coords_split[,"Y"] > (coords_intersect[1,"Y"] - 0.01)) &
                      (coords_split[,"Y"] < (coords_intersect[1,"Y"] + 0.01))
      idx_match_junc <- which(x_match_junc & y_match_junc)

      # Remove all coordinates between the extended vertex (included)
      # and the junction vertex (excluded)
      idx_near_junc <- ifelse(idx_match_junc[1] > idx_match_extended, idx_match_junc[1], idx_match_junc[2])
      coords_keep <- coords_split[-(idx_near_junc:idx_match_extended),-3]

      # Edit the coordinates at (mean) splitting point
      idx_junction <- ifelse(end, nrow(coords_keep), 1)
      coords_keep[idx_junction,] <- coords_junction

      # Remove duplicates vertices created by the splitting operation
      idx_duplicated <- which((diff(coords_keep[,"X"]) == 0) & (diff(coords_keep[,"Y"]) == 0))
      if (length(idx_duplicated)) coords_keep <- coords_keep[-c(idx_duplicated, idx_duplicated+1),]


      # Update geometry of the corrected segment
      sf::st_geometry(roads[pos,]) <- coords_keep |>
        sf::st_linestring() |>
        sf::st_sfc(crs = sf::st_crs(roads))
    }
  }

  return(roads)
}


#' Find intersection point between two lines as distance
#'
#' Find the closest intersection point between two lines
#' relative to a reference point on the second line.
#'
#' @param crossing_line  line (\code{sfc} format)
#' @param reference_line  line (\code{sfc} format). Reference line against which \code{crossing_line} intersection will be checked.
#' @param reference_point  point (\code{sfc} format). Point that must be on \code{reference_line} and that will be used to find
#' the closest intersection point of \code{crossing_line} to itself.
#'
#' @return Distance (\code{numeric}) between the beginning of \code{reference_line} and the closest intersection point to \code{reference_point}
#' on its path. \code{NA} is returned if no intersection occur.
#' @noRd
distance_line_intersection <- function(crossing_line, reference_line, reference_point)
{
  # Removing CRS information of reference_line/point allow
  # using distance_line_intersection() with functions
  # of the apply() family. Those function subset the
  # object passed as first argument meaning that if
  # a sfc_LINESTRING object is provided, only a
  # LINESTRING object will get passed to the function
  # which will cause an error later at sf::st_intersection()
  sf::st_crs(reference_line) <- NA
  sf::st_crs(reference_point) <- NA

  intersect_pts <- sf::st_intersection(reference_line, crossing_line)

  if (length(intersect_pts) == 0) return(NA)

  # Compute distance between each crossing of the
  # reference line and the reference point on this line
  # and only keep the closest crossing
  sp_line <- sf::as_Spatial(reference_line)
  sp_intersect <- sf::as_Spatial(sf::st_cast(intersect_pts, "POINT"))

  dist_intersect <- sapply(seq_along(sp_intersect), function(k) rgeos::gProject(sp_line, sp_intersect[k]))
  dist_point <- rgeos::gProject(sp_line, sf::as_Spatial(reference_point))
  dist_intersect_min <- dist_intersect[which.min(abs(dist_intersect - dist_point))]

  return(dist_intersect_min)
}


#' Find best connexion between two lines at a junction
#'
#' At a junction with multiples lines, find which two lines that are the most likely
#' to be the extension of each other. The prime factor is the angle formed between
#' each pair of lines (the flatter the better).
#'
#' @param tb_node  \code{tibble} containing info about the normalized heading, score and state of all lines
#' at a same junction.
#'
#' @return IDs (\code{character}) of the pair of lines having the best fit.
#' @noRd
find_best_connexion <- function(tb_node)
{
  comb_heading <- comb_state <- comb_score <- NULL

  m_row   <- utils::combn(seq(nrow(tb_node)), 2)
  m_angle <- utils::combn(tb_node[["norm_heading"]], 2)
  m_score <- utils::combn(tb_node[["SCORE"]], 2)
  m_state <- utils::combn(ifelse(tb_node[["CLASS"]] %in% c(1,2), tb_node[["CLASS"]], 3), 2)

  tb_similarity <- dplyr::tibble(
    pairs        = seq(ncol(m_row)),
    comb_heading = abs(abs(apply(m_angle, 2, diff)) - 90),
    comb_state   = apply(m_state, 2, sum),
    comb_score   = apply(m_score, 2, sum)) |>
    dplyr::mutate(comb_heading = ifelse(comb_heading > 80, 80, comb_heading)) |>
    dplyr::mutate(comb_state = ifelse(comb_state %in% c(1,2), comb_state, 3)) |>
    dplyr::arrange(dplyr::desc(comb_heading), comb_state, dplyr::desc(comb_score))

  # The best fit is based on (in order):
  #  - the angle formed between the segments (the flatter the better)
  #  - the state (corrected roads are favored)
  #  - the score (best overal score is favored)
  idx_best <- tb_similarity[1,][["pairs"]]
  ids_best <- tb_node[m_row[,idx_best],][["id"]]

  return(ids_best)
}


#' Combine two connected lines
#'
#' Find the mean coordinates of the two closest ends and combine
#' the two lines at this point to create a single continuous line
#' while maintaining history of the vertex order in the two
#' original lines.
#'
#' @param roads  lines (\code{sf} format). Corrected roads.
#' @param tb_node_bridge  \code{tibble} containing info about the two lines to be connected. Must contain
#' the corresponding row index in \code{roads} (field 'pos') as well as boolean value indicating if the vertex to connect correspond
#' to the end/tail one (field 'end').
#'
#' @return Named list containing the created \code{bridge} (as \code{sfc_LINESTRING}), the \code{junction} point (as \code{sfc_POINT})
#' and a vector indicating which line has been \code{reversed}.
#' @noRd
make_bridge <- function(roads, tb_node_bridge)
{
  end_1 <- tb_node_bridge[1,][["end"]]
  end_2 <- tb_node_bridge[2,][["end"]]
  pos_1 <- tb_node_bridge[1,][["pos"]]
  pos_2 <- tb_node_bridge[2,][["pos"]]
  coord_1 <- sf::st_coordinates(roads[pos_1,])[,-3]
  coord_2 <- sf::st_coordinates(roads[pos_2,])[,-3]
  rev_1 <- FALSE
  rev_2 <- FALSE

  # Sometimes, reversing direction of one of the
  # two segments is needed in order to obtain a
  # "continuous flow" of the vertices
  if (!end_1)
  {
    rev_1 <- TRUE
    coord_1 <- apply(coord_1, 2, rev)
    if (end_2)
    {
      rev_2 <- TRUE
      coord_2 <- apply(coord_2, 2, rev)
    }
  } else {
    if (end_2)
    {
      rev_2 <- TRUE
      coord_2 <- apply(coord_2, 2, rev)
    }
  }

  # Mean coordinates of the corrected road node on the bridge
  pt_junction <- apply(tb_node_bridge[,c("X","Y")], 2, mean) |>
    sf::st_point() |>
    sf::st_sfc(crs = sf::st_crs(roads))

  # Construct bridge with coordinates in the right order
  bridge <- rbind(coord_1[-nrow(coord_1),], sf::st_coordinates(pt_junction), coord_2[-1,]) |>
    sf::st_linestring() |>
    sf::st_sfc(crs = sf::st_crs(roads))

  return(list(bridge = bridge,
              junction = pt_junction,
              reversed = c(rev_1, rev_2)))
}
