#' Snap road endings without prior knowledge of road connections
#'
#' Snap road endings together to post-process and correct inaccuracies generated by \link{measure_roads}
#' and ensure getting topologically valid network.
#'
#' @param roads  multiples lines (sf format)
#' @param tolerance numeric. Tolerance value in distance unit used to snap the road endings
#'
#' @return The same object provided in input but with corrected ending such as roads are connected.
#' @export
st_snap_lines = function(roads, tolerance = 8)
{
  end   <- lwgeom::st_endpoint(roads)
  start <- lwgeom::st_startpoint(roads)
  ends  <- c(start, end)

  u <- sf::st_is_within_distance(ends, ends, tolerance)
  u <- lapply(u, sort)
  u <- Filter(function(x) { length(x) > 1}, u)
  u <- unique(u)
  u <- lapply(u, function(x) { ends[x] })
  u <- lapply(u, function(x) { sf::st_sfc(sf::st_point(colMeans(sf::st_coordinates(x)))) })
  u <- do.call(c, u)

  if (is.null(u)) {
    dist_unit <- sf::st_crs(u)$units
    warning(glue::glue("No roads could be snapped with the tolerance used ({tolerance} {dist_unit}). Original roads returned."), call. = FALSE)
    return(roads)
  }

  sf::st_crs(u) <- sf::st_crs(roads)

  v <- sf::st_is_within_distance(u, start, tolerance)
  for (i in seq_along(v))
  {
    ids <- v[[i]]
    for(j in ids)
    {
      sf::st_geometry(roads[j,])[[1]][1, 1] <- u[i][[1]][[1]]
      sf::st_geometry(roads[j,])[[1]][1, 2] <- u[i][[1]][[2]]
    }
  }

  w <- sf::st_is_within_distance(u, end, tolerance)
  for (i in seq_along(w))
  {
    ids <- w[[i]]
    for(j in ids)
    {
      n <- nrow(sf::st_geometry(roads[j,])[[1]])
      sf::st_geometry(roads[j,])[[1]][n, 1] <- u[i][[1]][[1]]
      sf::st_geometry(roads[j,])[[1]][n, 2] <- u[i][[1]][[2]]
    }
  }

  end   <- lwgeom::st_endpoint(roads)
  start <- lwgeom::st_startpoint(roads)
  idx_idem <- which(end == start)

  if (length(idx_idem)) {
    idx_roads <- glue::glue_collapse(idx_idem, ", ")
    warning(glue::glue("The following roads had both of their ends being snapped together: {idx_roads}"), call. = FALSE)
  }

  return(roads)
}


#' Snap road endings using prior knowledge of road connections
#'
#' Snap road endings together to post-process and correct inaccuracies generated by \link{measure_roads}
#' and ensure getting topologically valid network.
#'
#' @param roads  multiples lines (sf format). Corrected but unconnected roads.
#' @param roads_ori  multiples lines (sf format). Original non-corrected but connected roads.
#' @param field  character. Unique identifier field in both road datasets.
#' @param tolerance  numeric. For a specific jonction, maximal distance allowed between the new computed individual jonctions and the mean jonction.
#'
#' @return The same object provided in input but with corrected ending such as roads are connected.
#' @export
st_snap_lines2 <- function(roads, roads_ori, field, tolerance = 30)
{
  IDs1 <- sort(unique(roads[[field]]))
  IDs2 <- sort(unique(roads_ori[[field]]))
  if (!all(IDs1 == IDs2)) stop("Values in unique identifier field are not the same in both road datasets.", call. = FALSE)
  
  dist_unit <- sf::st_crs(roads)$units
  
  # Arrange both road datasets to make sure
  # that line indices will match between them
  roads <- dplyr::arrange(roads, field)
  roads_ori <- dplyr::arrange(roads_ori, field)
  
  prepare_data <- function(roads, end = FALSE)
  {
    if (end) {
      get_end <- lwgeom::st_endpoint
      suf <- sapply(sf::st_geometry(roads), nrow)
    } else {
      get_end <- lwgeom::st_startpoint
      suf <- 1
    }
    
    out <- get_end(roads) |>
      sf::st_coordinates() |>
      dplyr::as_tibble() |>
      dplyr::mutate(pos = 1:nrow(roads)) |>
      dplyr::mutate(limit = suf) |>
      dplyr::mutate(id = paste0(roads[[field]], "_", end))
    
    return(out)
  }
  
  # For the corrected roads, extraction of end points coordinates
  # and association with a unique identifier
  # Note that in "tb_ends_roads", entries of tb_endpoint must be
  # before those of tb_startpoint because this order is assumed
  # when updating the "limit" column elsewhere in the code
  tb_endpoint <- prepare_data(roads, TRUE)
  tb_startpoint <- prepare_data(roads, FALSE)
  
  ls_heading <- lapply(sf::st_geometry(roads), st_ends_heading)
  heading_tail_head <- c(sapply(ls_heading, tail, 1),
                         sapply(ls_heading, head, 1))
  
  tb_ends_roads <- rbind(tb_endpoint, tb_startpoint) |>
    dplyr::mutate(heading = heading_tail_head)
  
  # For the non-corrected roads, extraction of end points coordinates
  # and association with a unique identifier
  tb_endpoint <- prepare_data(roads_ori, TRUE)
  tb_startpoint <- prepare_data(roads_ori, FALSE)
  
  ls_heading <- lapply(sf::st_geometry(roads_ori), st_ends_heading)
  heading_tail_head <- c(sapply(ls_heading, tail, 1),
                         sapply(ls_heading, head, 1))
  
  tb_ends_ori <- rbind(tb_endpoint, tb_startpoint) |>
    dplyr::mutate(norm_heading = ifelse(heading_tail_head < 0, heading_tail_head + 180, heading_tail_head))
  
  # List of distinct connected nodes in the
  # non-corrected road dataset
  tb_nodes <- dplyr::distinct(tb_ends_ori, X, Y)
  ls_group_ids <- lapply(1:nrow(tb_nodes), function(ii) 
  {
    dplyr::filter(tb_ends_ori,
                  X == tb_nodes[ii,][["X"]] &
                  Y == tb_nodes[ii,][["Y"]])[["id"]]
  })
  
  
  for (ii in seq_along(ls_group_ids))
  {
    group_ids <- ls_group_ids[[ii]]
    tb_group <- dplyr::filter(tb_ends_ori, id %in% group_ids)
    been_corrected <- any(roads[tb_group[["pos"]],][["STATE"]] %in% c(1,2))
    
    # Will only try snapping if more than one segment is in the group
    # as well as if at least one of the segments in the group has been corrected
    if (length(group_ids) == 1 | !been_corrected) next
    
    
    # Find the two segments that are the most
    # likely to be the extension of each other
    # Those two are marked out as the "bridge"
    bridge_ids <- find_best_connexion(tb_group)
    
    
    # Mean coordinates of the corrected road node on the bridge
    tb_node_bridge <- dplyr::filter(tb_ends_roads, id %in% bridge_ids)
    x_bridge <- mean(tb_node_bridge[["X"]])
    y_bridge <- mean(tb_node_bridge[["Y"]])
    bridge_junction <- sf::st_sfc(sf::st_point(c(x_bridge, y_bridge)), crs = sf::st_crs(roads))
    
    
    # If there is only two segments, there is no need
    # to try finding a better junction point with a
    # non-existent third or fourth segment...
    if (length(group_ids) == 2)
    {
      # Update geometry of the two corrected segments composing the bridge
      for (j in 1:2)
      {
        lim <- tb_node_bridge[j,][["limit"]]
        pos <- tb_node_bridge[j,][["pos"]]
        
        sf::st_geometry(roads[pos,])[[1]][lim, 1] <- x_bridge
        sf::st_geometry(roads[pos,])[[1]][lim, 2] <- y_bridge
      }
      next
    }
    
    
    # Merge the two segments forming the bridge.
    # This will allow for an easier split when the 
    # exact position of the junction will be found.
    ls_bridge <- st_make_bridge(roads, tb_node_bridge)
    bridge <- ls_bridge[["bridge"]]
    reversed_lines <- ls_bridge[["reversed"]]
    
    
    # Find intersection points between the remaining
    # segments and the bridge. The intersection point
    # is given as the distance on the path between
    # the begining of the bridge and intersection point
    remain_ids <- group_ids[!(group_ids %in% bridge_ids)]
    tb_node_remain <- dplyr::filter(tb_ends_roads, id %in% {{remain_ids}})
    dist_bridge <- sapply(seq_along(remain_ids),
                          bridge_intersection,
                          roads,
                          bridge,
                          bridge_junction,
                          tb_node_remain)
    
    valid_intersection <- !sapply(dist_bridge, is.na)
    
    
    # Won't try to find a junction point on the bridge
    # if no remaining segment truly intersected the bridge
    if (all(!valid_intersection)) next
    
    
    # Check if all intersections occur within the tolerance
    # value of the mean. If not, edit none of the roads
    # Certainly not the better way to handle this
    dist_junction <- mean(dist_bridge[valid_intersection])
    dist_junction_diff <- abs(dist_bridge[valid_intersection] - dist_junction)
    if (max(dist_junction_diff) > tolerance)
    {
      x_old <- round(tb_node_remain[1,][["X"]])
      y_old <- round(tb_node_remain[1,][["Y"]])
      warning(glue::glue("Some roads crosses bridge too far from each other (> {tolerance} {dist_unit}). Roads at this junction won't be snapped. X:{x_old} Y:{y_old}"), call.=FALSE)
      next
    }
    
    # Find coordinates of the point where
    # all remaining segments intersect the bridge
    # based on the mean intersection distance
    # along the bridge from its begining
    junction_point <- st_point_on_path(dist_junction, bridge)
    
    
    # Split bridge geometry to recreate the original
    # two segments composing it
    ls_split <- split_bridge(junction_point, bridge, reversed_lines)
    bridge_geometries <- ls_split[["geometries"]]
    coords_junction <- ls_split[["junction"]]
    
    
    # Update geometry of the two corrected segments composing the bridge
    pos <- tb_node_bridge[["pos"]]
    sf::st_geometry(roads[pos,]) <- bridge_geometries
    
    
    # Update "limit" values in tb_ends_roads table
    # as the splitting operation might change the
    # total number of vertices in the geometry
    tb_ends_roads[pos, "limit"] <- c(nrow(bridge_geometries[[1]]),
                                     nrow(bridge_geometries[[2]]))
    
    
    # Update coordinates of remaining segments
    # by splitting in order to avoid potential
    # overlapping segment if it was already crossing
    # the bridge before elongation
    for (j in which(valid_intersection))
    {
      pos <- tb_node_remain[j,][["pos"]]
      n <- tb_node_remain[j,][["limit"]]
      heading <- tb_node_remain[j,][["heading"]]*pi/180
      
      road_ori <- roads[pos,] # Copie superflue?
      coords_road_ori <- sf::st_coordinates(road_ori)[,-3]
      
      x_remain <- sf::st_geometry(road_ori)[[1]][n, 1] + 999999 * cos(heading)
      y_remain <- sf::st_geometry(road_ori)[[1]][n, 2] + 999999 * sin(heading)
      
      sf::st_geometry(road_ori)[[1]][n, 1] <- x_remain
      sf::st_geometry(road_ori)[[1]][n, 2] <- y_remain
      
      splitted_road <- lwgeom::st_split(road_ori, bridge)
      road_features <- sf::st_collection_extract(splitted_road, "LINESTRING")
      
      
      # Extract vertices coordinates corresponding
      # to the bulk of the original segment.
      # This is done by checking which feature has
      # an end matching the coordinates of the end
      # on the original segment which wasn't part
      # of the orginal junction
      n_opposite <- if(n == 1) nrow(coords_road_ori) else n
      coords_opposite <- coords_road_ori[n_opposite,]
      
      coords_splitted <- sf::st_coordinates(road_features)
      
      idx_match <- (coords_splitted[,-3] == coords_opposite) |>
        apply(1, all) |>
        which()
      
      nLinestring <- coords_splitted[idx_match, 3]
      coords_keep <- coords_splitted[coords_splitted[,3] == nLinestring, -3]
      
      
      # Edit the coordinates at splitting point
      # to make sure that it is exactly the same as
      # coords_junction. May not be necessary...
      coords_keep[n,1:2] <- coords_junction
      
      
      # Update geometry of the corrected segment
      sf::st_geometry(roads[pos,]) <- coords_keep |>
        sf::st_linestring() |>
        sf::st_sfc(crs = sf::st_crs(roads))
      
      
      # Update "limit" values in tb_ends_roads table
      # as the splitting operation might change the 
      # total number of vertices in the geometry
      tb_ends_roads[pos, "limit"] <- nrow(coords_keep)
    }
  }
  
  return(roads)
}


bridge_intersection <- function(j, roads, bridge, bridge_junction, tb_node_remain)
{
  pos <- tb_node_remain[j,][["pos"]]
  n <- tb_node_remain[j,][["limit"]]
  heading <- tb_node_remain[j,][["heading"]]*pi/180
  
  road_copy <- roads[pos,] # Copie peut-être pas nécessaire
  
  x_remain <- sf::st_geometry(road_copy)[[1]][n, 1] + 999999 * cos(heading)
  y_remain <- sf::st_geometry(road_copy)[[1]][n, 2] + 999999 * sin(heading)
  
  sf::st_geometry(road_copy)[[1]][n, 1] <- x_remain
  sf::st_geometry(road_copy)[[1]][n, 2] <- y_remain
  
  pts_intersect <- sf::st_intersection(bridge, sf::st_geometry(road_copy))
  
  if (length(pts_intersect) == 0)
  {
    x_old <- round(sf::st_geometry(roads[pos,])[[1]][n,1])
    y_old <- round(sf::st_geometry(roads[pos,])[[1]][n,2])
    warning(glue::glue("{tb_node_remain[j,][['id']]} never crosses bridge. This end of the road won't be snapped. X:{x_old} Y:{y_old}"), call.=FALSE)
    return(NA)
  }
  
  # Compute the distance between each crossing and the bridge junction
  # Only the closest crossing is kept
  sp_bridge <- sf::as_Spatial(bridge)
  sp_intersect <- sf::as_Spatial(sf::st_cast(pts_intersect, "POINT"))
  
  dist_bridge <- NA
  for (k in seq_along(sp_intersect))
  {
    dist_bridge[k] <- rgeos::gProject(sp_bridge, sp_intersect[k])
  }
  dist_junction <- rgeos::gProject(sp_bridge, sf::as_Spatial(bridge_junction))
  dist_bridge <- dist_bridge[which.min(abs(dist_bridge - dist_junction))]

  return(dist_bridge)
}



find_best_connexion <- function(tb_group)
{
  m_row <- combn(1:nrow(tb_group), 2)
  m_angle <- combn(tb_group[["norm_heading"]], 2)
  m_score <- combn(roads[tb_group[["pos"]],][["SCORE"]], 2)
  states <- roads[tb_group[["pos"]],][["STATE"]]
  m_state <- combn(ifelse(states %in% c(1,2), states, 3), 2)
  
  tb_similarity <- dplyr::tibble(
    pairs = 1:ncol(m_row),
    comb_heading = abs(abs(m_angle[1,] - m_angle[2,]) - 90),
    comb_state   = m_state[1,] + m_state[2,],
    comb_score   = m_score[1,] + m_score[2,]) |>
      dplyr::mutate(comb_heading = ifelse(comb_heading > 80, 80, comb_heading)) |>
      dplyr::mutate(comb_state = ifelse(comb_state %in% c(1,2), comb_state, 3)) |>
      dplyr::arrange(dplyr::desc(comb_heading), comb_state, dplyr::desc(comb_score))
  
  # The best fit is based on (on order):
  #  - the angles formed between the segments (the flatter the better)
  #  - the state (corrected roads are favored)
  #  - the score (best overal score is favored)
  idx_best <- tb_similarity[1,][["pairs"]]
  bridge_ids <- tb_group[m_row[,idx_best],][["id"]]
  
  return(bridge_ids)
}


st_make_bridge <- function(roads, tb_node_bridge)
{
  lim_1 <- tb_node_bridge[1,][["limit"]]
  lim_2 <- tb_node_bridge[2,][["limit"]]
  pos_1 <- tb_node_bridge[1,][["pos"]]
  pos_2 <- tb_node_bridge[2,][["pos"]]
  coord_1 <- sf::st_coordinates(roads[pos_1,])[,-3]
  coord_2 <- sf::st_coordinates(roads[pos_2,])[,-3]
  rev_1 <- FALSE
  rev_2 <- FALSE
  
  # Sometimes, reversing direction of one of the
  # two segments is needed in order to obtain a
  # "continuous flow" of the vertices.
  if (lim_1 == 1)
  {
    rev_1 <- TRUE
    coord_1[,1] <- rev(coord_1[,1])
    coord_1[,2] <- rev(coord_1[,2])
    if (lim_2 != 1)
    {
      rev_2 <- TRUE
      coord_1[,1] <- rev(coord_1[,1])
      coord_1[,2] <- rev(coord_1[,2])
      coord_2[,1] <- rev(coord_2[,1])
      coord_2[,2] <- rev(coord_2[,2])
    }
  } else {
    if (lim_2 != 1)
    {
      rev_2 <- TRUE
      coord_2[,1] <- rev(coord_2[,1])
      coord_2[,2] <- rev(coord_2[,2])
    }
  }
  
  # Construct bridge with coordinates
  # in the right order
  n <- nrow(coord_1)

  bridge <- rbind(coord_1[-n, ], c(x_bridge, y_bridge), coord_2[-1,]) |>
    sf::st_linestring() |>
    sf::st_sfc(crs = sf::st_crs(roads))

  return(list(bridge = bridge,
              reversed = c(rev_1, rev_2)))
}


st_point_on_path <- function(distance, path)
{
  # This function is the reverse of rgeos::gProject()
  
  coords <- sf::st_coordinates(path)
  
  dist_lagged <- sqrt(diff(coords[,1])^2 + diff(coords[,2])^2)
  dist_along_path <- data.frame(dist = dist_lagged,
                                cumsum = cumsum(dist_lagged))
  
  idx <- which(dist_along_path[,2] >= distance)[1]
  
  theta <- atan2(coords[idx+1,2] - coords[idx,2],
                 coords[idx+1,1] - coords[idx,1])
  hypo <- distance - dist_along_path[idx,2] + dist_along_path[idx,1]
  
  x_junction <- coords[idx,1] + hypo * cos(theta)
  y_junction <- coords[idx,2] + hypo * sin(theta)
  
  return(c(x_junction, y_junction, theta = unname(theta)))
}


split_bridge <- function(junction_point, bridge, reversed_lines){
  # Make a small perpendicular linestring for
  # the splitting operation as the point itself may
  # not be perfectly aligned with the bridge path
  # (due to floating point precision?)
  x1_blade <- junction_point["X"] + 0.1 * cos(junction_point["theta"]+pi/2)
  y1_blade <- junction_point["Y"] + 0.1 * sin(junction_point["theta"]+pi/2)
  x2_blade <- junction_point["X"] - 0.1 * cos(junction_point["theta"]+pi/2)
  y2_blade <- junction_point["Y"] - 0.1 * sin(junction_point["theta"]+pi/2)
  blade <- sf::st_linestring(rbind(c(x1_blade, y1_blade), c(x2_blade, y2_blade)))
  
  # Split bridge at junction to reconstruct the (updated)
  # two original segments composing it
  bridge_collection <- lwgeom::st_split(bridge, blade)
  bridge_geometries <- sf::st_collection_extract(bridge_collection, "LINESTRING")
  
  # Get precise coordinates of the real split
  coords_junction <- sf::st_coordinates(bridge_geometries[2])[1,-3]
  
  # Reorder vertices in order to match the original
  # two segments forming the bridge
  if (reversed_lines[1])
  {
    coord <- sf::st_coordinates(bridge_geometries[1])
    coord[,1] <- rev(coord[,1])
    coord[,2] <- rev(coord[,2])
    bridge_geometries[1][[1]] <- sf::st_linestring(coord[,1:2])
  }
  if (reversed_lines[2])
  {
    coord <- sf::st_coordinates(bridge_geometries[2])
    coord[,1] <- rev(coord[,1])
    coord[,2] <- rev(coord[,2])
    bridge_geometries[2][[1]] <- sf::st_linestring(coord[,1:2])
  }
  
  return(list(geometries = bridge_geometries,
              junction = coords_junction))
}