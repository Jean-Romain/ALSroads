#' Snap road endings without prior knowledge of road connections
#'
#' Snap road endings together to post-process and correct inaccuracies generated by \link{measure_roads}
#' and ensure getting topologically valid network.
#'
#' @param roads  multiples lines (sf format)
#' @param tolerance numeric. Tolerance value in distance unit used to snap the road endings
#'
#' @return The same object provided in input but with corrected ending such as roads are connected.
#' @export
st_snap_lines = function(roads, tolerance = 8)
{
  end   <- lwgeom::st_endpoint(roads)
  start <- lwgeom::st_startpoint(roads)
  ends  <- c(start, end)

  u <- sf::st_is_within_distance(ends, ends, tolerance)
  u <- lapply(u, sort)
  u <- Filter(function(x) { length(x) > 1}, u)
  u <- unique(u)
  u <- lapply(u, function(x) { ends[x] })
  u <- lapply(u, function(x) { sf::st_sfc(sf::st_point(colMeans(sf::st_coordinates(x)))) })
  u <- do.call(c, u)

  if (is.null(u)) {
    dist_unit <- sf::st_crs(u)$units
    warning(glue::glue("No roads could be snapped with the tolerance used ({tolerance} {dist_unit}). Original roads returned."), call. = FALSE)
    return(roads)
  }

  sf::st_crs(u) <- sf::st_crs(roads)

  v <- sf::st_is_within_distance(u, start, tolerance)
  for (i in seq_along(v))
  {
    ids <- v[[i]]
    for(j in ids)
    {
      sf::st_geometry(roads[j,])[[1]][1, 1] <- u[i][[1]][[1]]
      sf::st_geometry(roads[j,])[[1]][1, 2] <- u[i][[1]][[2]]
    }
  }

  w <- st_is_within_distance(u, end, tolerance)
  for (i in seq_along(w))
  {
    ids <- w[[i]]
    for(j in ids)
    {
      n <- nrow(sf::st_geometry(roads[j,])[[1]])
      sf::st_geometry(roads[j,])[[1]][n, 1] <- u[i][[1]][[1]]
      sf::st_geometry(roads[j,])[[1]][n, 2] <- u[i][[1]][[2]]
    }
  }

  end   <- lwgeom::st_endpoint(roads)
  start <- lwgeom::st_startpoint(roads)
  idx_idem <- which(end == start)

  if (length(idx_idem)) {
    idx_roads <- glue::glue_collapse(idx_idem, ", ")
    warning(glue::glue("The following roads had both of their ends being snapped together: {idx_roads}"), call. = FALSE)
  }

  return(roads)
}


#' Snap road endings using prior knowledge of road connections
#'
#' Snap road endings together to post-process and correct inaccuracies generated by \link{measure_roads}
#' and ensure getting topologically valid network.
#'
#' @param roads  multiples lines (sf format). Corrected but unconnected roads.
#' @param roads_ori  multiples lines (sf format). Original non-corrected but connected roads.
#' @param field  character. Unique identifier field in both road datasets.
#' @param weight  numeric (between 0 and 1). Weight that the coordinates of prior connections should have.
#' @param tolerance  numeric. Maximal distance allowed between the orignal position of road endings and and the new computed one.
#'
#' @return The same object provided in input but with corrected ending such as roads are connected.
#' @export
st_snap_lines2 <- function(roads, roads_ori, field, weight = 0, tolerance = Inf)
{
  if (!all(sort(unique(roads[[field]])) == sort(unique(roads_ori[[field]])))) stop("Range of unique field in both road datasets is not the same.", call. = FALSE)
  if (nrow(roads) != nrow(roads_ori)) stop("Size of both road datasets is not the same.", call. = FALSE)
  
  dist_unit <- sf::st_crs(roads)$units

  # Arrange both road datasets to make sure
  # that line indices will match between them
  roads <- dplyr::arrange(roads, .data[[field]])
  roads_ori <- dplyr::arrange(roads_ori, .data[[field]])
  

  # For the corrected roads, extraction of end points coordinates
  # and association with a unique identifier
  tb_endpoint <- lwgeom::st_endpoint(roads) %>%
    sf::st_coordinates() %>%
    as_tibble() %>%
    dplyr::mutate(pos = 1:nrow(roads)) %>%
    dplyr::mutate(limit = "end") %>%
    dplyr::mutate(id = paste0(roads[[field]], "_", limit))
  
  tb_startpoint <- lwgeom::st_startpoint(roads) %>%
    sf::st_coordinates() %>%
    as_tibble() %>%
    dplyr::mutate(pos = 1:nrow(roads)) %>%
    dplyr::mutate(limit = "start") %>%
    dplyr::mutate(id = paste0(roads[[field]], "_", limit))
  
  tb_ends_roads <- rbind(tb_endpoint, tb_startpoint)
  
  # For the non-corrected roads, extraction of end points coordinates
  # and association with a unique identifier
  tb_endpoint <- lwgeom::st_endpoint(roads_ori) %>%
    sf::st_coordinates() %>%
    as_tibble() %>%
    dplyr::mutate(pos = 1:nrow(roads_ori)) %>%
    dplyr::mutate(limit = "end") %>%
    dplyr::mutate(id = paste0(roads_ori[[field]], "_", limit))
  
  tb_startpoint <- lwgeom::st_startpoint(roads_ori) %>%
    sf::st_coordinates() %>%
    as_tibble() %>%
    dplyr::mutate(pos = 1:nrow(roads_ori)) %>%
    dplyr::mutate(limit = "start") %>%
    dplyr::mutate(id = paste0(roads_ori[[field]], "_", limit))
  
  tb_ends_ori <- rbind(tb_endpoint, tb_startpoint)
  
  
  # List of distinct connected nodes in the
  # non-corrected road dataset
  tb_nodes <- dplyr::distinct(tb_ends_ori, X, Y)
  ls_group_ids <- lapply(1:nrow(tb_nodes), function(ii) {
    dplyr::filter(tb_ends_ori, X == tb_nodes[ii,][["X"]] & Y == tb_nodes[ii,][["Y"]])[["id"]]
  })
  
  
  for(ii in 1:nrow(tb_nodes)) {
    group_ids <- ls_group_ids[[ii]]
    if(length(group_ids) > 1) {
      
      # Coordinates of the original road node
      x_ori <- tb_nodes[ii,][["X"]]
      y_ori <- tb_nodes[ii,][["Y"]]
      
      # Mean coordinates of the corrected road node
      tb_node_cor <- dplyr::filter(tb_ends_roads, id %in% group_ids)
      x_cor <- mean(tb_node_cor[["X"]])
      y_cor <- mean(tb_node_cor[["Y"]])
      
      # New computed node coordinates
      x_new <- x_cor * (1 - weight) + x_ori * weight
      y_new <- y_cor * (1 - weight) + y_ori * weight
      
      # Check for tolerance
      max_dist <- max(sqrt((tb_node_cor[["X"]] - x_new)^2 + (tb_node_cor[["Y"]] - y_new)^2))
      if (max_dist > tolerance){
        pos <- tb_node_cor[["pos"]]
        values_field <- glue::glue_collapse(roads[pos,][[field]], ", ")
        warning(glue::glue("Roads with {field} == {values_field} could not be snapped together due to the tolerance used ({max_dist} > {tolerance} {dist_unit}). Original roads returned."), call. = FALSE)
      } else {
        # Update coordinates
        for(j in seq_along(group_ids)){
          pos <- tb_node_cor[j,][["pos"]]
          n <- 1
          if(tb_node_cor[j,][["limit"]] == "end"){
            n <- nrow(sf::st_geometry(roads[pos,])[[1]])
          }
          sf::st_geometry(roads[pos,])[[1]][n, 1] <- x_new
          sf::st_geometry(roads[pos,])[[1]][n, 2] <- y_new
        }
      }
    }
  }
  return(roads)
}

sinuosity <- function(x)
{
  UseMethod("sinuosity", x)
}

sinuosity.matrix = function(x)
{
  m  <- nrow(x)

  dx <- diff(x[,1])
  dy <- diff(x[,2])
  L  <- sum(sqrt(dx^2 + dy^2))

  dx <- diff(x[c(1,m),1])
  dy <- diff(x[c(1,m),2])
  D  <- sum(sqrt(dx^2 + dy^2))

  return(L/D)
}

sinuosity.sf <- function(x)
{
  lines <- x
  n <- nrow(lines)
  S <- numeric(n)
  for (i in 1:n)
  {
    line <- lines[i,]

    if (sf::st_geometry_type(line) != "LINESTRING")
      stop(paste0("Geometry ", i, " is not a LINESTRING"))

    S[i] <- sinuosity.sfc_LINESTRING(line)
  }

  round(S,2)
}

sinuosity.sfc_LINESTRING <- function(x)
{
  XY <- sf::st_coordinates(x)
  return(sinuosity.matrix(XY))
}

adjust_spline = function(points)
{
  # Adjust a spline to create a smooth line from points
  xroad <- sf::st_coordinates(points)[,1]
  yroad <- sf::st_coordinates(points)[,2]
  troad <- points$distance_to_start
  wroad <- points$find_score

  ux <- stats::smooth.spline(troad, xroad, spar = 0.4, all.knots = TRUE)
  uy <- stats::smooth.spline(troad, yroad, spar = 0.4, all.knots = TRUE)

  # Sometime one point is missing in the spline for an unknown reason. If the output
  # does not have the same length than the input we resize the input to fit the output
  # and prevent failures
  rm <- FALSE
  if (length(ux$x) < length(troad))
  {
    rm <- troad %in% ux$x
    xroad = xroad[rm]
    yroad = yroad[rm]
    troad = troad[rm]
    wroad = wroad[rm]
  }

  # Maybe it is possible to have an extra point. This case is handled here but never observed
  if (length(ux$x) > length(troad))
  {
    print(dput(points))
    stop("Different length")
  }

  # The adjusted spline can be far from some outlier points. This is the role of the spline
  # to smooth the road. But if some important outliers are detected far from the spline (more than
  # 10 m) we remove those points and fit again the spline
  rm2 <- FALSE
  rmx <- abs(ux$y - xroad) < 10
  rmy <- abs(uy$y - yroad) < 10

  if (any(!rmx) | any(!rmy))
  {
    rm2   <- rmx & rmy
    xroad <- xroad[rm2]
    yroad <- yroad[rm2]
    troad <- troad[rm2]
    wroad <- wroad[rm2]

    if (length(xroad) > 3)
    {
      ux <- stats::smooth.spline(troad, xroad, w = wroad)
      uy <- stats::smooth.spline(troad, yroad, w = wroad)
    }
    else
    {
      rm2 <- FALSE
    }
  }

  spline <- sf::st_drop_geometry(points)
  if (!isFALSE(rm))  spline <- spline[rm,]
  if (!isFALSE(rm2)) spline <- spline[rm2,]
  spline$x <- ux$y
  spline$y <- uy$y
  spline <- sf::st_as_sf(spline, coords = c("x", "y"))

  return(sf::st_sfc(sf::st_linestring(sf::st_coordinates(spline))))
}

st_merge_line = function(x)
{
  u <- sf::st_geometry(sf::st_linestring(sf::st_coordinates(sf::st_cast(sf::st_geometry(x), "POINT"))))
  u <- sf::st_set_crs(u, sf::st_crs(x))
  return(u)
}

st_is_loop = function(line)
{
  # Exit early for loops because does not work (yet?)
  p1 <- lwgeom::st_startpoint(line)
  p2 <- lwgeom::st_endpoint(line)
  d  <- as.numeric(sf::st_distance(p1,p2)[1,1])
  return(d < 2)
}

st_angles <- function(line)
{
  M <- sf::st_coordinates(line)
  M <- M[,-3]

  n = nrow(M)
  if (n < 3) return(0)

  angles <- numeric(n)
  angles[] <- NA_real_
  for (i in 2:(n-1))
  {
    Ax = M[i-1,1]
    Ay = M[i-1,2]
    Bx = M[i,1]
    By = M[i,2]
    Cx = M[i+1,1]
    Cy = M[i+1,2]
    u <- c(Bx-Ax, By-Ay)
    v <- c(Cx-Bx, Cy-By)
    angles[i] <- angle(u,v)
  }

   return(abs(angles[-c(1,n)]))
}

angle <- function(x,y)
{
  dot.prod <- x%*%y
  norm.x <- norm(x,type="2")
  norm.y <- norm(y,type="2")
  theta <- acos(dot.prod / (norm.x * norm.y))
  as.numeric(theta)*180/pi
}
